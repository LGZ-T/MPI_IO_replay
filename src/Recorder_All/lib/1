#! /usr/bin/python

import re
# TODO: fh's value is not consistant

OUTPUTFILE = 'sample_file'

def generate_head(code_file, out_file):
	data = '/* \n *This file is generated automaticaly by wrapper generator.\n'
	data += ' * define neccessary variables below\n'
	data += ' */\n\n'

	data += '#include "simple_compress.h"\n'
	# sc should be initialized in input header
	data += 'SimpleCompress *sc;\n\n'

	data += 'struct timespec tm1, tm2;\n'
	data += 'int ret, result_len;\n'
	data += 'char comm_name[100], etype_name[100], filetype_name[100], datatype_name[100], oldtype_name, newtype_name[100];\n'

	# add buffer
	data += '#define BUFFER_SIZE 4096\n'
	data += 'const int threshold = BUFFER_SIZE * 0.9;\n'
	data += 'int bytes, written_bytes;\n'
	data += 'char rec_buffer[4096];\n\n'


# copy initialzation from recorder
	try:
		all_the_text = code_file.read()
	finally:
		code_file.close()

	data += all_the_text
	out_file.write(data)

	return


def generate_one_function(para_list, out_file):
	if len(para_list) < 3:
		return 1

# generate function head
	head = ''
	head += para_list[1] + ' '	# return type
	func_name = para_list[0].lstrip('P') + '('
	head += func_name	# function name

	for index, para in enumerate(para_list):
		if index > 1:
			head += para + ','
	
	head = head[:-1]
	head += ')\n'

# generate function body
	paras = para_list[2:]
	
	def datatype_code(datatype):
		datatype_code = '''PMPI_Type_get_name(%(data)s, %(data)s_name, &result_len);\n
		if (result_len == 0) {
			sprintf(%(data)s_name, "%%ld", %(data)s);
		}
		'''
		result = datatype_code % {'data' : datatype}
		return result

	get_name = {'comm': 'PMPI_Comm_get_name(comm, comm_name, &result_len);\n', 
				'datatype': datatype_code('datatype'),
				'etype': datatype_code('etype'),
				'filetype': datatype_code('filetype'),
				'oldtype' : datatype_code('oldtype'),
				'newtype': 'sprintf(newtype_name, "%ld", *newtype);\n'}

	para_format = {
			'MPI_File' : '%ld',
			'MPI_Offset' : '%ld',
			'MPI_Datatype' : '%s',
			'MPI_Comm' : '%s',
			'MPI_Status' : '%ld',
			'MPI_Info' : '%ld',
			'MPI_Op' : '%ld',
			'MPI_Request' : '%ld',
			'MPI_Aint' : '%ld',
			'int' : '%d',
			'char' : '%s',
			}
				
	call_para = '('
	extra_data = ''
	after_call = ''
	print_format_1 = '"tm1=%ld.%.9ld tm2=%ld.%.9ld func=' + para_list[0].lstrip('P') + ' '
	print_format_2 = 'tm1.tv_sec, tm1.tv_nsec, tm2.tv_sec, tm2.tv_nsec'
	call_delim = ', '
	delim = ' '
	para_delim = ', '
	for para in paras:
		type_of_para =  str(para.split()[0])
		true_para = str(para.split()[1])
		pointer = true_para.startswith('*')
		call_para += true_para.lstrip('*').rstrip('[]')
		call_para += call_delim
		true_para = true_para.rstrip('[]')

		
		extra = get_name.get(true_para.lstrip('*'), None)
		if extra is not None:
			# for MPI_Datatype*
			if pointer == True and type_of_para == 'MPI_Datatype':
				true_true_para = true_para.lstrip('*')
				after_call += 'sprintf(%s_name, "%%ld", *' + true_para.lstrip('*') + ');\n' % true_true_para
			else:
				extra_data += extra
			
			extra = None
			
			print_format_1 += true_para.lstrip('*') + '=' + para_format.get(type_of_para, 'Error') + delim
			print_format_2 += para_delim + true_para.lstrip('*') + '_name'
		elif pointer == True:
			# for void *buf, int *comm, int *size, etc.
			if type_of_para == 'void' or type_of_para == 'int':
				print_format_1 += true_para.lstrip('*') + '=' + true_para.lstrip("*") + delim
			else:
				print_format_1 += true_para.lstrip('*') + '=' + para_format.get(type_of_para, 'Error') + delim
				if type_of_para == 'MPI_File': # only use address
					#print_format_2 += ', ' + true_para
					print_format_2 += para_delim + '*' + true_para.lstrip("*")
				else:
					print_format_2 += para_delim + true_para.lstrip('*')

		else:
			print_format_1 += true_para.lstrip('*') + '=' + para_format.get(type_of_para, 'Error') + delim
			if type_of_para == 'MPI_File':
				print_format_2 += para_delim + true_para
			#	print_format_2 += para_delim + true_para
			else:
				print_format_2 += para_delim + true_para
	
	#print_format_1 = print_format_1[:-1]
	print_format_1 += '\\n"' + para_delim

			
	call_para = call_para[:-2]
	call_para += ')'

	body = '{\n'
	body += '\t/* tm1 is the length of time elapsed between the IO or MPI communication calls. It\'s spend in computing */\n'
	body += '\ttm1 = ts_minus(recorder_wtime(), tm2);\n'
	body += extra_data
	body += '\tret = RECORDER_MPI_CALL(' + para_list[0] + ')' + call_para + ';\n'
	body += after_call
	body += '\ttm2 = ts_minus(recorder_wtime(), tm1);\n'

#	body += '\tif (__recorderfh != NULL)\n'
	body += '\tbytes = sprintf(rec_buffer + written_bytes, ' + print_format_1 + delim + print_format_2 + ');\n'
	body += '\tread_func(sc, rec_buffer);\n'
	body += '\twrite_or_compress(sc);\n'

	''' 
	does not need buffer here
	body += "\twritten_bytes += bytes;\n"
	body += "\tif (written_bytes > threshold) {\n"
	body += "\t\tfputs(rec_buffer, __recorderfh);\n"
	body += "\t\twritten_bytes = 0;\n}\n\n"
	'''

	body += '\t/* tm2 stands for the true exit moment of this function */\n'
	body += '\ttm2 = recorder_wtime();\n'

	body += '\treturn ret;\n'
	body += '}\n\n'

	result = head + body
	out_file.write(result)
	return 0
		

def process(line, goodbye, out_file):
	recorder_prefix = 'RECORDER_FORWARD_DECL'
	print line	
	if line.startswith(recorder_prefix) == False:
		return 1
	
	#strip prefix and parathens
	striped = line[len(recorder_prefix):-2]
	
	if striped.startswith(goodbye):
		print "!!!!!!!!!!! Bye !!!!!!!!!!"
		return 2

	print striped
	para_list = []
	temp = striped.split(',')
	print temp
	for para in temp:
		bone = para.strip(' ()')
		if len(bone) > 0:
			para_list += [bone]

	generate_one_function(para_list, out_file)

	return 0

if __name__ == '__main__':
	input_file = open("../recorder-mpi-init-finalize-compress.c")
	output_file = open('sample_output.c', 'w')
	input_header = open('input_header_compress')

	generate_head(input_header, output_file)
	for line in input_file:
		if process(line, '(PMPI_Finalize', output_file) == 2:
			break

	input_file.close()
	output_file.close()
